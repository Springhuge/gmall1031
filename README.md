# gmall 1031 本地修改版本

=====================================================================
使用window连接linux上的zookeeper时一定要将虚拟机的防火墙关闭才可以连接
关闭防火墙命令:service  iptables stop
=====================================================================

gamll-user-service 用户服务的service层8070
gamll-user-web用户服务的web层8080

gmall-manage-service 后台管理service层 8071
gmall-manage-web 后台管理用户service层 8081

# gmall-item-service 前台的商品详情服务 8072 直接调用manage-service服务
gmall-item-web 前台的商品详情展示 8082


=======================================================================
前后端跨域问题：
    端口号不同，ip地址不同都是跨域问题
    
 1.前端127.0.0.1:8888   
 2.后端127.0.0.1:8080
 前端和后端因为来自不同的网域，所以在http的安全协议策略下，不信任
 3.解决方案:
    a.在前端请求添加跨域协议
    b.在SpringMvc的控制层加入@CrossOrigin跨域访问的注解
==================================================================

引入分布式文件系统 fastdfs
引入thymeleaf模板技术
引入redis


增加一个redis工具类，用来初始化redis的池子
增加一个redis配置类，将redis的配置写入spring的容器中

=======================================================================================================================================
redis 常见问题：
    1.缓存在高并发和安全压力下的一些问题
        a.缓存击穿:对一些设置了过期时间的key，如果这些key可能会在某些时间点被高并发的访问，是一种非常"热点"的数据。这个时候，需要考虑一个
     问题:如果这个key在大量请求同时进来前正好失效，那么所有对这个key的数据查询都落到db，我们成为缓存击穿。
        和缓存雪崩的区别:
            击穿是一个热点key失效
            雪崩是很多key集体失效
         解决:
        b.缓存穿透:是指查询一个一定不存在的数据，由于缓存时不命中，将去查询数据库，但是数据库也无此记录，并且处于容错考虑，我们没有将这次
    查询的null值写入缓存，这将导致这个不存在的的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利
    用这个不存在的key频繁攻击我们的应用，这就是漏洞。
        解决:空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。    
        c.缓存雪崩:缓存雪崩式指我们在设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。
            解决:原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的福哦其时间的重复率就会降低，就很难引发集体失效
        的事件。  
    2.如何解决缓存的问题
        使用redis数据库的分布式锁，解决mysql的访问压力问题
        
=======================================================================================================================================